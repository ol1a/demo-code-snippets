import { expect } from 'chai';
import { ethers } from 'hardhat';
import { Contract } from 'ethers';
import { Exploit } from '../typechain-types';

describe('Lock', function () {
  let meow: Contract;
  let exploit: Exploit;
  let rbtcAmount = ethers.utils.parseEther('0.001');

  async function deploy() {
    const MeowFactory = await ethers.getContractFactory('Meow');
    meow = await MeowFactory.deploy();
    await meow.deployed();
    const ExploitFactory = await ethers.getContractFactory('Exploit');
    exploit = await ExploitFactory.deploy();
    await exploit.deployed();
  }

  before(deploy);

  it('should not allow to send RBTC to Meow directly', async () => {
    const [signer] = await ethers.getSigners();
    const tx = signer.sendTransaction({
      to: meow.address,
      value: rbtcAmount,
      gasLimit: '30000',
    });
    await expect(tx).to.be.revertedWithoutReason();
  });

  it('Meow balance should stay zero after failed transfer attempt', async () => {
    expect(await ethers.provider.getBalance(meow.address)).to.equal(0);
  });

  it('should top up Meow balance through Exploit', async () => {
    const tx = exploit.payNoMatterWhat(meow.address, {
      value: rbtcAmount,
    });
    await expect(() => tx).to.changeEtherBalance(meow, rbtcAmount);
  });
});
